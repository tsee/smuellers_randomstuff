package ExtUtils::CAPI;
use strict;
use warnings;

use DynaLoader;

sub export_functions {
  my %opt = @_;
  my $module = $opt{module} // die "Need 'module' option";
  my $header = $opt{header} // die "Need 'header' option";
  my $functions = $opt{functions} // die "Need 'functions' option";
  $functions = {%$functions};
  
  my @func_names = keys %$functions;
  foreach my $funcname (@func_names) {
    my $func_ptr_type = $functions->{$funcname};
    my %func_def = (func_ptr_type => $func_ptr_type);

    ($func_def{func_ptr} = $func_ptr_type) =~ s/\(\s*\*\s*\)/(*${funcname}_ptr)/
      or die "Invalid function pointer type? '$func_ptr_type'";

    ($func_def{signature} = $func_ptr_type) =~ s/\(\s*\*\s*\)/($funcname)/
      or die "Failed to generate signature from function pointer type '$func_ptr_type' syntax";

    $functions->{$funcname} = \%func_def;
  }

  open my $hdr_fh, ">", $header
    or die "Cannot open header file '$header' for writing: $!";

  (my $guard = "CAPI_$module") =~ s/[^A-Za-z_]/_/g;
  print $hdr_fh "#ifndef $guard\n#define $guard\n";
  print $hdr_fh "/* This code is autogenerated. Do not edit it! */\n\n";

  my $module_name_define = $module;
  $module_name_define =~ s/::/_/g;
  $module_name_define =~ s/[^A-Za-z0-9_]/_/g;

  # Write out macro for defining the fptr symbols and
  # at the same time write out the actual fptr symbols as "extern"
  # declarations.
  SCOPE: {
    print $hdr_fh "\n";
    my @macro_code;
    foreach my $i (0 .. $#func_names) {
      my $funcname = $func_names[$i];
      my $code = $functions->{$funcname}->{func_ptr} . ";";
      push @macro_code, $code;
      print $hdr_fh "extern $code\n\n";
    }
    print $hdr_fh "\n";
    print $hdr_fh
      _make_macro("DEFINE_SYMBOLS_$module_name_define", @macro_code);
    print $hdr_fh "\n";
  }

  print $hdr_fh "\n\n";

  # Write out macro for initializing the fptrs.
  SCOPE: {
    my @macro_code;
    push @macro_code, <<'HERE';
  HV *symbols;
  I32 count;
  dSP;
  
  ENTER;
  SAVETMPS;
  PUSHMARK(SP);
HERE

    push @macro_code,
      "  EXTEND(SP, " . (scalar(@func_names)+1) . ");",
      "  PUSHs(sv_2mortal(newSVpvs(\"$module\")));",
      map {
        "  PUSHs(sv_2mortal(newSVpvs(\"$_\")));"
      } @func_names;
    push @macro_code, <<'HERE';
  
  PUTBACK;
  count = call_pv("ExtUtils::CAPI::_resolve_symbols", G_SCALAR);
  SPAGAIN;
  if (count != 1)
    croak("Failed to init symbols");
  
  symbols = (HV *)SvRV(POPs);
HERE

    foreach my $funcname (@func_names) {
      push @macro_code,
        "  ${funcname}_ptr = (void *)SvIV(*hv_fetchs(symbols, \"$funcname\", 0));";
    }

    push @macro_code, <<'HERE';
  PUTBACK;
  FREETMPS;
  LEAVE;
HERE

    print $hdr_fh "\n",
      _make_stmt_macro("INIT_SYMBOLS_$module_name_define", @macro_code), "\n";
  }

  print $hdr_fh "\n";

  print $hdr_fh "\n\n#endif\n";
  close $hdr_fh;
}

sub _make_stmt_macro {
  my ($name, @code) = @_;
  return _make_macro($name, "STMT_START {", @code, "} STMT_END");
}

sub _make_macro {
  my ($name, @code) = @_;
  my $code = join "\n", @code;
  $code =~ s/^/  /mg;
  $code =~ s/$/ \\/mg;
  $code =~ s/[\\\s]+\z//s;
  return "#define $name \\\n$code";
}


# Required for _resolve_symbols.
# Mostly lifted from DynaLoader.pm's bootstrap():
# Locates/opens lib files or dies trying.
sub find_lib {
  my ($module) = @_;

  my @modparts = split(/::/,$module);
  my $modfname = $modparts[-1];

  # Some systems have restrictions on files names for DLL's etc.
  # mod2fname returns appropriate file base name (typically truncated)
  # It may also edit @modparts if required.
  $modfname = &DynaLoader::mod2fname(\@modparts) if defined &DynaLoader::mod2fname;

  my $modpname = join('/',@modparts);
  my $file;
  my @dirs;
  foreach my $incdir (@INC) {
    my $dir = "$incdir/auto/$modpname";

    next unless -d $dir; # skip over uninteresting directories

    # check for common cases to avoid autoload of dl_findfile
    my $try = "$dir/$modfname.$DynaLoader::dl_dlext";
    last if $file = ($DynaLoader::do_expand) ? DynaLoader::dl_expandspec($try) : ((-f $try) && $try);

    # no luck here, save dir for possible later dl_findfile search
    push @dirs, $dir;
  }

  # last resort, let dl_findfile have a go in all known locations
  $file = DynaLoader::dl_findfile(map("-L$_", @dirs, @INC), $modfname) unless $file;
  if (not defined $file) {
    die "Failed to locate shared library for module '$module'";
  }
  return DynaLoader::dl_load_file($file);
}




# This is called from the generated C. Be extra careful about
# changing its visible behaviour.
sub _resolve_symbols {
  my ($module, @symbols) = @_;
  my $libhandle = find_lib($module);
  if (not defined $libhandle) {
    croak("Could not locate shared library for module '$module'");
  }
  my %syms;
  foreach my $symbol (@symbols) {
    my $sym = DynaLoader::dl_find_symbol($libhandle, $symbol);
    if (not defined $sym) {
      croak("Could not resolve symbol '$symbol' for module '$module'");
    }
    $syms{$symbol} = $sym;;
  }
  return \%syms;
}
1;
